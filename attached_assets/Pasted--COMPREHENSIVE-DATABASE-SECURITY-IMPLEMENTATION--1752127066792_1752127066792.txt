-- COMPREHENSIVE DATABASE SECURITY IMPLEMENTATION
-- =============================================

/*
## DATABASE SECURITY IMPLEMENTATION GUIDE

This script implements a comprehensive security system for your Supabase database, including:

1. AUDIT SYSTEM
   - Creates an audit schema with a centralized logs table
   - Implements trigger functions to automatically track all data changes
   - Records who changed what and when, including the original and changed data
   - Provides helper functions to easily apply audit to tables

2. ROW LEVEL SECURITY (RLS) IMPROVEMENTS
   - Enables RLS on tables that don't have it
   - Adds missing policies for tables with RLS but no policies
   - Provides functions to replace problematic 'FOR ALL' policies

3. PERFORMANCE OPTIMIZATIONS
   - Adds indexes for foreign key columns to improve query performance
   - Particularly important for columns used in RLS policies

4. SECURITY HEALTH CHECK FUNCTIONS
   - Creates database functions to identify security issues
   - Supports the security-health-check Edge Function

5. AUDIT TRIGGER APPLICATION
   - Applies audit triggers to important tables
   - Provides examples for adding more tables to the audit system

## IMPLEMENTATION PLAN

1. Review this script carefully before running
2. Execute the script in your Supabase SQL Editor
3. Deploy the security-health-check Edge Function
4. Run the security health check to verify improvements
5. Monitor audit logs regularly

*/

-- =============================================
-- PART 1: AUDIT SYSTEM IMPLEMENTATION
-- =============================================

-- Create audit schema
CREATE SCHEMA IF NOT EXISTS audit;

-- Create audit log table
CREATE TABLE IF NOT EXISTS audit.logs (
    id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    table_name text NOT NULL,
    user_id uuid,
    action text NOT NULL CHECK (action IN ('INSERT', 'UPDATE', 'DELETE', 'TRUNCATE')),
    row_data jsonb,
    changed_fields jsonb,
    query text,
    ip_address inet,
    timestamp timestamptz NOT NULL DEFAULT now()
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON audit.logs (table_name);
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit.logs (user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit.logs (timestamp);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit.logs (action);

-- Enable RLS on the audit logs table
ALTER TABLE audit.logs ENABLE ROW LEVEL SECURITY;

-- Create policy to allow only admins to view audit logs
CREATE POLICY admin_audit_access ON audit.logs
    FOR SELECT
    TO authenticated
    USING (
        (SELECT is_admin FROM public.users WHERE auth_user_id = auth.uid()) = true
    );

-- Create the audit trigger function
CREATE OR REPLACE FUNCTION audit.create_audit_trigger()
RETURNS TRIGGER AS $$
DECLARE
    row_data jsonb;
    changed_fields jsonb;
    include_old boolean;
    include_new boolean;
    log_row jsonb;
    excluded_cols text[] = ARRAY[]::text[];
BEGIN
    IF TG_WHEN <> 'AFTER' THEN
        RAISE EXCEPTION 'audit.create_audit_trigger() may only run as an AFTER trigger';
    END IF;

    -- Determine which row to log
    CASE TG_OP
        WHEN 'INSERT' THEN
            row_data = to_jsonb(NEW);
            changed_fields = NULL;
            include_old = false;
            include_new = true;
        WHEN 'UPDATE' THEN
            -- Only log if something actually changed
            IF NEW IS DISTINCT FROM OLD THEN
                row_data = to_jsonb(OLD);
                
                -- Calculate changed fields
                SELECT jsonb_object_agg(key, value) INTO changed_fields
                FROM jsonb_each(to_jsonb(NEW))
                WHERE to_jsonb(NEW) -> key IS DISTINCT FROM to_jsonb(OLD) -> key
                  AND key NOT IN (SELECT unnest(excluded_cols));
                
                include_old = true;
                include_new = true;
            ELSE
                -- No actual change, skip logging
                RETURN NULL;
            END IF;
        WHEN 'DELETE' THEN
            row_data = to_jsonb(OLD);
            changed_fields = NULL;
            include_old = true;
            include_new = false;
        WHEN 'TRUNCATE' THEN
            row_data = NULL;
            changed_fields = NULL;
            include_old = false;
            include_new = false;
        ELSE
            RAISE EXCEPTION 'audit.create_audit_trigger() triggered for unhandled event: %', TG_OP;
    END CASE;

    -- Build the audit log entry
    INSERT INTO audit.logs (
        table_name,
        user_id,
        action,
        row_data,
        changed_fields,
        query,
        ip_address
    )
    VALUES (
        TG_TABLE_SCHEMA || '.' || TG_TABLE_NAME,
        (CASE WHEN current_setting('request.jwt.claims', true)::jsonb ? 'sub' 
              THEN (current_setting('request.jwt.claims', true)::jsonb ->> 'sub')::uuid 
              ELSE NULL END),
        TG_OP,
        row_data,
        changed_fields,
        current_query(),
        (CASE WHEN current_setting('request.headers', true)::jsonb ? 'x-forwarded-for' 
              THEN (regexp_split_to_array(current_setting('request.headers', true)::jsonb ->> 'x-forwarded-for', ','))[1]::inet 
              ELSE NULL END)
    );

    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- Create a function to easily add audit triggers to tables
CREATE OR REPLACE FUNCTION audit.add_audit_trigger(target_table regclass)
RETURNS void AS $$
DECLARE
    trigger_name text;
BEGIN
    -- Generate a trigger name based on the table
    SELECT 'audit_trigger_' || relname INTO trigger_name
    FROM pg_class
    WHERE oid = target_table;
    
    -- Create the trigger
    EXECUTE format('DROP TRIGGER IF EXISTS %I ON %s', trigger_name, target_table);
    EXECUTE format('CREATE TRIGGER %I AFTER INSERT OR UPDATE OR DELETE ON %s FOR EACH ROW EXECUTE FUNCTION audit.create_audit_trigger()', 
                  trigger_name, target_table);
    
    RAISE NOTICE 'Added audit trigger to table: %', target_table;
END;
$$ LANGUAGE plpgsql;

-- Create a function to add audit triggers to all tables in a schema
CREATE OR REPLACE FUNCTION audit.add_audit_triggers_to_schema(schema_name text)
RETURNS void AS $$
DECLARE
    tables RECORD;
BEGIN
    FOR tables IN 
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = schema_name
        AND tablename NOT LIKE 'pg_%'
    LOOP
        PERFORM audit.add_audit_trigger(schema_name || '.' || tables.tablename);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Create a function to add audit triggers to specific tables
CREATE OR REPLACE FUNCTION audit.add_audit_triggers_to_tables(table_names text[])
RETURNS void AS $$
DECLARE
    table_name text;
BEGIN
    FOREACH table_name IN ARRAY table_names
    LOOP
        PERFORM audit.add_audit_trigger(table_name::regclass);
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Create helper views for audit analysis
CREATE OR REPLACE VIEW audit.recent_activity AS
SELECT 
    logs.id,
    logs.table_name,
    u.username,
    logs.action,
    logs.changed_fields,
    logs.timestamp
FROM 
    audit.logs
LEFT JOIN 
    auth.users u ON logs.user_id = u.id
WHERE 
    logs.timestamp > (now() - interval '24 hours')
ORDER BY 
    logs.timestamp DESC;

-- Create view for admin dashboard
CREATE OR REPLACE VIEW audit.activity_summary AS
SELECT 
    date_trunc('hour', timestamp) AS hour,
    table_name,
    action,
    count(*) AS action_count
FROM 
    audit.logs
WHERE 
    timestamp > (now() - interval '7 days')
GROUP BY 
    date_trunc('hour', timestamp),
    table_name,
    action
ORDER BY 
    hour DESC, 
    table_name;

-- =============================================
-- PART 2: RLS POLICY IMPROVEMENTS
-- =============================================

-- Create a function to enable RLS on tables that don't have it
CREATE OR REPLACE FUNCTION public.enable_rls_on_tables(table_names text[])
RETURNS void AS $$
DECLARE
    table_name text;
BEGIN
    FOREACH table_name IN ARRAY table_names
    LOOP
        EXECUTE format('ALTER TABLE %s ENABLE ROW LEVEL SECURITY', table_name);
        RAISE NOTICE 'Enabled RLS on table: %', table_name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Enable RLS on tables that need it (example tables - adjust as needed)
SELECT public.enable_rls_on_tables(ARRAY[
    'public.group_members',
    'public.group_visitors',
    'public.groups',
    'public.help_supports',
    'public.invites',
    'public.media_tags',
    'public.pinned_groups',
    'public.profiles',
    'public.reports',
    'public.settings',
    'public.user_languages',
    'public.user_profiles',
    'public.user_travels'
]);

-- Create RLS policies for tables that are missing them
-- For chat_room_users
CREATE POLICY "Users can view their own chat rooms" ON public.chat_room_users
    FOR SELECT
    TO authenticated
    USING (user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "Users can join chat rooms" ON public.chat_room_users
    FOR INSERT
    TO authenticated
    WITH CHECK (user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "Users can leave chat rooms" ON public.chat_room_users
    FOR DELETE
    TO authenticated
    USING (user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

-- For blocked_users
CREATE POLICY "Users can view their blocked list" ON public.blocked_users
    FOR SELECT
    TO authenticated
    USING (user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "Users can block others" ON public.blocked_users
    FOR INSERT
    TO authenticated
    WITH CHECK (user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

CREATE POLICY "Users can unblock others" ON public.blocked_users
    FOR DELETE
    TO authenticated
    USING (user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid()));

-- Create a function to fix 'FOR ALL' policies by replacing them with specific action policies
CREATE OR REPLACE FUNCTION public.replace_all_policy(
    table_name text,
    policy_name text,
    using_condition text
) RETURNS void AS $$
BEGIN
    -- Drop the existing ALL policy
    EXECUTE format('DROP POLICY IF EXISTS %I ON %s', policy_name, table_name);
    
    -- Create separate policies for each action
    EXECUTE format('
        CREATE POLICY %I_select ON %s
        FOR SELECT
        TO authenticated
        USING (%s)
    ', policy_name, table_name, using_condition);
    
    EXECUTE format('
        CREATE POLICY %I_insert ON %s
        FOR INSERT
        TO authenticated
        WITH CHECK (%s)
    ', policy_name, table_name, using_condition);
    
    EXECUTE format('
        CREATE POLICY %I_update ON %s
        FOR UPDATE
        TO authenticated
        USING (%s)
        WITH CHECK (%s)
    ', policy_name, table_name, using_condition, using_condition);
    
    EXECUTE format('
        CREATE POLICY %I_delete ON %s
        FOR DELETE
        TO authenticated
        USING (%s)
    ', policy_name, table_name, using_condition);
    
    RAISE NOTICE 'Replaced ALL policy % on table % with specific action policies', policy_name, table_name;
END;
$$ LANGUAGE plpgsql;

-- Example usage of replace_all_policy function (uncomment and modify as needed)
-- SELECT public.replace_all_policy(
--     'public.posts',
--     'Users can manage their own posts',
--     'user_id = (SELECT id FROM public.users WHERE auth_user_id = auth.uid())'
-- );

-- =============================================
-- PART 3: PERFORMANCE OPTIMIZATIONS
-- =============================================

-- Create indexes for foreign keys that are missing them
-- This improves query performance, especially for tables used in RLS policies

-- users table
CREATE INDEX IF NOT EXISTS idx_users_user_type ON public.users(user_type);

-- user_api_tokens table
CREATE INDEX IF NOT EXISTS idx_user_api_tokens_user_id ON public.user_api_tokens(user_id);

-- user_otps table
CREATE INDEX IF NOT EXISTS idx_user_otps_user_id ON public.user_otps(user_id);

-- blocked_users table
CREATE INDEX IF NOT EXISTS idx_blocked_users_blocked_user_id ON public.blocked_users(blocked_user_id);

-- activities table
CREATE INDEX IF NOT EXISTS idx_activities_parent_id ON public.activities(parent_id);

-- posts table
CREATE INDEX IF NOT EXISTS idx_posts_activity_id ON public.posts(activity_id);
CREATE INDEX IF NOT EXISTS idx_posts_original_post_id ON public.posts(original_post_id);
CREATE INDEX IF NOT EXISTS idx_posts_shared_by ON public.posts(shared_by);
CREATE INDEX IF NOT EXISTS idx_posts_feeling_id ON public.posts(feeling_id);

-- post_comments table
CREATE INDEX IF NOT EXISTS idx_post_comments_parent_comment_id ON public.post_comments(parent_comment_id);

-- post_comment_likes table
CREATE INDEX IF NOT EXISTS idx_post_comment_likes_user_id ON public.post_comment_likes(user_id);

-- post_shares table
CREATE INDEX IF NOT EXISTS idx_post_shares_user_id ON public.post_shares(user_id);

-- saved_posts table
CREATE INDEX IF NOT EXISTS idx_saved_posts_user_id ON public.saved_posts(user_id);

-- hidden_posts table
CREATE INDEX IF NOT EXISTS idx_hidden_posts_user_id ON public.hidden_posts(user_id);

-- groups table
CREATE INDEX IF NOT EXISTS idx_groups_creator_id ON public.groups(creator_id);

-- events table
CREATE INDEX IF NOT EXISTS idx_events_event_type_id ON public.events(event_type_id);
CREATE INDEX IF NOT EXISTS idx_events_creator_id ON public.events(creator_id);

-- chat_rooms table
CREATE INDEX IF NOT EXISTS idx_chat_rooms_creator_id ON public.chat_rooms(creator_id);

-- chat_messages table
CREATE INDEX IF NOT EXISTS idx_chat_messages_reply_to_id ON public.chat_messages(reply_to_id);

-- memories table
CREATE INDEX IF NOT EXISTS idx_memories_event_id ON public.memories(event_id);

-- media table
CREATE INDEX IF NOT EXISTS idx_media_reused_in_memory ON public.media(reused_in_memory);
CREATE INDEX IF NOT EXISTS idx_media_memory_id ON public.media(memory_id);

-- =============================================
-- PART 4: SECURITY HEALTH CHECK FUNCTIONS
-- =============================================

-- Function to get tables without RLS
CREATE OR REPLACE FUNCTION public.get_tables_without_rls()
RETURNS TABLE(schemaname text, tablename text) AS $$
BEGIN
    RETURN QUERY
    SELECT t.schemaname, t.tablename
    FROM pg_tables t
    WHERE t.schemaname = 'public'
    AND t.tablename NOT IN (
        SELECT tablename 
        FROM pg_tables 
        WHERE rowsecurity = true AND schemaname = 'public'
    )
    ORDER BY t.tablename;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- Function to get tables with RLS but no policies
CREATE OR REPLACE FUNCTION public.get_tables_without_policies()
RETURNS TABLE(schemaname text, tablename text) AS $$
BEGIN
    RETURN QUERY
    SELECT t.schemaname, t.tablename
    FROM pg_tables t
    LEFT JOIN (
        SELECT schemaname, tablename
        FROM pg_policies
        WHERE schemaname = 'public'
        GROUP BY schemaname, tablename
    ) p ON t.schemaname = p.schemaname AND t.tablename = p.tablename
    WHERE t.schemaname = 'public' AND t.rowsecurity = true AND p.tablename IS NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- Function to get foreign keys without indexes
CREATE OR REPLACE FUNCTION public.get_foreign_keys_without_indexes()
RETURNS TABLE(table_name text, column_name text, foreign_table text, foreign_column text) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tc.table_name::text,
        kcu.column_name::text,
        ccu.table_name::text AS foreign_table,
        ccu.column_name::text AS foreign_column
    FROM 
        information_schema.table_constraints AS tc 
        JOIN information_schema.key_column_usage AS kcu
          ON tc.constraint_name = kcu.constraint_name
          AND tc.table_schema = kcu.table_schema
        JOIN information_schema.constraint_column_usage AS ccu
          ON ccu.constraint_name = tc.constraint_name
    WHERE tc.constraint_type = 'FOREIGN KEY'
    AND tc.table_schema = 'public'
    AND NOT EXISTS (
        SELECT 1 FROM pg_indexes i 
        WHERE i.tablename = tc.table_name
        AND i.schemaname = tc.table_schema
        AND i.indexdef LIKE '%' || kcu.column_name || '%'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- Function to get tables with FOR ALL policies
CREATE OR REPLACE FUNCTION public.get_tables_with_all_policies()
RETURNS TABLE(schemaname text, tablename text, policyname text) AS $$
BEGIN
    RETURN QUERY
    SELECT p.schemaname, p.tablename, p.policyname
    FROM pg_policies p
    WHERE p.schemaname = 'public'
    AND p.cmd = 'ALL'
    ORDER BY p.tablename;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- Function to check if audit functionality exists
CREATE OR REPLACE FUNCTION public.check_audit_functionality()
RETURNS json AS $$
DECLARE
    result json;
BEGIN
    SELECT json_build_object(
        'exists', EXISTS (
            SELECT 1 
            FROM information_schema.schemata 
            WHERE schema_name = 'audit'
        ) AND EXISTS (
            SELECT 1 
            FROM information_schema.tables 
            WHERE table_schema = 'audit' 
            AND table_name = 'logs'
        )
    ) INTO result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = '';

-- =============================================
-- PART 5: APPLY AUDIT TRIGGERS TO IMPORTANT TABLES
-- =============================================

-- Apply audit triggers to the most important tables
SELECT audit.add_audit_triggers_to_tables(ARRAY[
    'public.users',
    'public.posts',
    'public.post_comments',
    'public.events',
    'public.event_participants',
    'public.friends',
    'public.chat_rooms',
    'public.chat_messages',
    'public.media',
    'public.memories'
]);

-- You can add more tables as needed by uncommenting and modifying:
-- SELECT audit.add_audit_triggers_to_tables(ARRAY[
--     'public.table_name1',
--     'public.table_name2'
-- ]);

-- Or apply to all tables in the public schema (use with caution on large databases):
-- SELECT audit.add_audit_triggers_to_schema('public');

/*
-- =============================================
-- SECURITY HEALTH CHECK EDGE FUNCTION
-- =============================================

After running this SQL script, deploy the following Edge Function using the Supabase Dashboard or CLI:

Function name: security-health-check

Code:
```typescript
// security-health-check.ts
import { createClient } from 'npm:@supabase/supabase-js@2.39.3'

interface SecurityIssue {
  severity: 'high' | 'medium' | 'low';
  issue_type: string;
  description: string;
  recommendation: string;
  affected_objects: string[];
}

Deno.serve(async (req) => {
  try {
    // Only allow POST requests
    if (req.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method not allowed' }), {
        status: 405,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Get authorization header
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(JSON.stringify({ error: 'Authorization required' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Create Supabase client with admin privileges
    // Note: This should be restricted to admin users only
    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );

    // Verify the user is an admin
    const { data: { user }, error: userError } = await supabaseAdmin.auth.getUser(
      authHeader.replace('Bearer ', '')
    );

    if (userError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Check if user is admin
    const { data: userData, error: roleError } = await supabaseAdmin
      .from('users')
      .select('is_admin')
      .eq('auth_user_id', user.id)
      .single();

    if (roleError || !userData?.is_admin) {
      return new Response(JSON.stringify({ error: 'Admin privileges required' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Run security checks
    const issues: SecurityIssue[] = [];

    // Check 1: Tables without RLS
    const { data: tablesWithoutRLS, error: rlsError } = await supabaseAdmin.rpc('get_tables_without_rls');
    if (!rlsError && tablesWithoutRLS) {
      if (tablesWithoutRLS.length > 0) {
        issues.push({
          severity: 'high',
          issue_type: 'Missing RLS',
          description: 'Tables without Row Level Security enabled',
          recommendation: 'Enable RLS on these tables and add appropriate policies',
          affected_objects: tablesWithoutRLS.map((t: any) => `${t.schemaname}.${t.tablename}`)
        });
      }
    }

    // Check 2: Tables with RLS but no policies
    const { data: tablesWithoutPolicies, error: policiesError } = await supabaseAdmin.rpc('get_tables_without_policies');
    if (!policiesError && tablesWithoutPolicies) {
      if (tablesWithoutPolicies.length > 0) {
        issues.push({
          severity: 'high',
          issue_type: 'Missing Policies',
          description: 'Tables with RLS enabled but no policies defined',
          recommendation: 'Add appropriate policies to these tables',
          affected_objects: tablesWithoutPolicies.map((t: any) => `${t.schemaname}.${t.tablename}`)
        });
      }
    }

    // Check 3: Foreign keys without indexes
    const { data: fkWithoutIndexes, error: fkError } = await supabaseAdmin.rpc('get_foreign_keys_without_indexes');
    if (!fkError && fkWithoutIndexes) {
      if (fkWithoutIndexes.length > 0) {
        issues.push({
          severity: 'medium',
          issue_type: 'Missing Indexes',
          description: 'Foreign keys without indexes can cause performance issues',
          recommendation: 'Create indexes on these foreign key columns',
          affected_objects: fkWithoutIndexes.map((fk: any) => `${fk.table_name}.${fk.column_name}`)
        });
      }
    }

    // Check 4: Tables using FOR ALL policies
    const { data: allPolicies, error: allPoliciesError } = await supabaseAdmin.rpc('get_tables_with_all_policies');
    if (!allPoliciesError && allPolicies) {
      if (allPolicies.length > 0) {
        issues.push({
          severity: 'medium',
          issue_type: 'FOR ALL Policies',
          description: 'Tables using FOR ALL in RLS policies (not recommended)',
          recommendation: 'Replace with specific action policies (SELECT, INSERT, UPDATE, DELETE)',
          affected_objects: allPolicies.map((p: any) => `${p.schemaname}.${p.tablename}.${p.policyname}`)
        });
      }
    }

    // Check 5: Check for audit functionality
    const { data: auditCheck, error: auditError } = await supabaseAdmin.rpc('check_audit_functionality');
    if (!auditError && auditCheck && !auditCheck.exists) {
      issues.push({
        severity: 'medium',
        issue_type: 'Missing Audit',
        description: 'No comprehensive audit system detected',
        recommendation: 'Implement audit logging for sensitive tables',
        affected_objects: ['database']
      });
    }

    // Return the security report
    return new Response(JSON.stringify({
      timestamp: new Date().toISOString(),
      total_issues: issues.length,
      issues: issues,
      summary: {
        high: issues.filter(i => i.severity === 'high').length,
        medium: issues.filter(i => i.severity === 'medium').length,
        low: issues.filter(i => i.severity === 'low').length
      }
    }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('Error in security health check:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
});
```
*/

