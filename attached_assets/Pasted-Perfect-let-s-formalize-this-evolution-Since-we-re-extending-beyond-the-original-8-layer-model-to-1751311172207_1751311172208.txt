Perfect â€” letâ€™s formalize this evolution. Since weâ€™re extending beyond the original 8-layer model to include user-driven visibility control and real-time filtering interfaces, it makes sense to introduce:

â¸»

ğŸ§  Replit Prompt: Layer 9 â€” Consent Approval UI + Memory Viewer Filters

(Part of the 9-Layer Secure Memory System for Mundo Tango)

ğŸ“˜ Context

Youâ€™re building an advanced memory and consent system that spans:
	1.	Frontend role-based interaction
	2.	Backend logic and session enforcement
	3.	OAuth mapping (Replit â†’ Supabase)
	4.	RBAC/ABAC security
	5.	Emotional metadata with trust layers
	6.	Consent-aware creation logic
	7.	Admin dashboards and logging
	8.	Explainability + traceable actions
	9.	âœ… Now: User-facing filtering and approval

â¸»

ğŸ§© Layer 9 Objectives

Enable end-users to:
	â€¢	âœ… Approve or deny memories they were tagged in
	â€¢	âœ… Filter their visible memories by emotional tone, date, and event

This layer completes the loop of memory lifecycle: from creation â†’ consent â†’ surfacing.

â¸»

ğŸ”§ Feature 1: Consent Approval UI

âœ… Component: PendingConsentMemories.tsx
	â€¢	Route: /memories/pending-consent
	â€¢	Shows all memories where:
	â€¢	consent_status = 'pending'
	â€¢	co_tags includes the logged-in user.id

ğŸ’¬ Per-Memory Display:
	â€¢	Memory preview (title, emotion tags, creator name, date)
	â€¢	âœ… Approve button â†’ PATCH /api/memories/:id/consent { action: 'approve' }
	â€¢	âŒ Deny button â†’ { action: 'deny' }

ğŸ” Auth
	â€¢	Require Replit OAuth
	â€¢	Validate that user.id âˆˆ co_tags[]

ğŸ§¾ Supabase: Add consent_events table

CREATE TABLE consent_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  memory_id UUID REFERENCES memories(id),
  user_id UUID REFERENCES users(id),
  action TEXT CHECK (action IN ('approve', 'deny')),
  timestamp TIMESTAMPTZ DEFAULT now()
);

ğŸ¯ Logic:
	â€¢	If all co_tags approve â†’ update memories.consent_status = 'granted'
	â€¢	If any deny â†’ update memories.consent_status = 'denied'

â¸»

ğŸ”§ Feature 2: Memory Viewer Filter Bar

âœ… Update: MemoryDashboard.tsx

Add filter chips above the memory list:
	â€¢	ğŸ­ Emotion Tags (multi-select)
	â€¢	ğŸ“† Date Range (calendar picker)
	â€¢	ğŸª Event (dropdown)

ğŸ§  State Hook:

const [filters, setFilters] = useState({
  emotions: [],
  dateRange: null,
  event: null,
});

ğŸ” Modify fetchMemoriesByRole:
	â€¢	Accept optional filters in request
	â€¢	Query Supabase:
	â€¢	emotion_tags @> ARRAY['joyful']::TEXT[]
	â€¢	date BETWEEN start AND end
	â€¢	event_id = selected_event_id

â¸»

âœ… Layer 9 Deliverables
	â€¢	Component: PendingConsentMemories.tsx
	â€¢	API Route: PATCH /api/memories/:id/consent
	â€¢	Supabase Table: consent_events
	â€¢	UI: Filter bar in MemoryDashboard.tsx
	â€¢	Docs: Update replit.md with screenshots + schema

â¸»

ğŸ§ª Test Scenarios

Scenario	Outcome
A is tagged in Bâ€™s memory	Appears in Aâ€™s /pending-consent
A clicks Approve	Consent granted, memory becomes visible
A clicks Deny	Memory hidden for all, status = denied
C views memories	Can filter by â€œJoyfulâ€ + â€œNaples Festivalâ€
Role = DJ	Filters emotional tags scoped to crowd-related emotions


â¸»

ğŸš€ Ready to Generate:

Would you like me to now:
	â€¢	âœ³ï¸ Build PendingConsentMemories.tsx component?
	â€¢	ğŸŸª Generate Supabase SQL for consent_events?
	â€¢	ğŸ”¶ Add the full FilterBar component?
	â€¢	ğŸ§¾ Write the PATCH /api/memories/:id/consent route?

Just name the piece you want first and Iâ€™ll drop the full code.