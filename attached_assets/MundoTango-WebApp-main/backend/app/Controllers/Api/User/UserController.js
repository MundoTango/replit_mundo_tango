const _ = require("lodash");

const {
  validateAll,
  validateAsync,
  compareHash,
  extractFields,
  generateHash,
} = require("../../../Helper/index.js");
const FileHandler = require("../../../Libraries/FileHandler/FileHandler.js");

const RestController = require("../../RestController");
const SocialUser = require("../../../Models/SocialUser.js");
const UserApiToken = require("../../../Models/UserApiToken.js");
const UserOTP = require("../../../Models/UserOTP.js");
const { LOGIN_TYPE } = require("../../../config/enum.js");
const constants = require("../../../config/constants.js");

class UserController extends RestController {
  constructor() {
    super("User");
    this.resource = "User";
    this.request; //adonis request obj
    this.response; //adonis response obj
    this.params = {}; // this is used for get parameters from url
  }

  async validation(action, id = 0) {
    let validator = [];
    let rules;
    let customMessages = {
      required: "You forgot to give a :attribute",
      "regex.password":
        "Password must contain atleast one number and one special character and should be 6 to 16 character long",
      same: ":attribute is not same as password",
    };

    switch (action) {
      case "store":
        rules = {
          first_name: "required|min:3|max:50",
          last_name: "required|min:3|max:50",
          email: "required|email|unique:users,email|max:50",
          mobile_no: ["required", "unique:users,mobile_no"],
          password: [
            "required",
            "regex:/^(?=.*[0-9])(?=.*[!@#$%^&*])[a-zA-Z0-9!@#$%^&*]{6,16}$/",
          ],
          confirm_password: "required|same:password",
        };

        validator = await validateAsync(
          this.request.body,
          rules,
          customMessages
        );

        break;
      case "update":
        break;
    }
    return validator;
  }

  async beforeUpdateLoadModel() {
    this.params.id = this.request.user.slug;
    if (!this.request.files?.length) return;

    try {
      const fileObject = this.request.files;
      const image_url = await FileHandler.doUpload(fileObject[0]);
      this.request.image_url = image_url;
      return;
    } catch (err) {
      this.__is_error = true;
      console.log(err);
      return this.sendError("Failed to upload user image", {}, 500);
    }
  }
  
  async afterStoreLoadModel(record) {
    this.__collection = false;
    return {};
  }

  async afterShowLoadModel() {
    this.resource = "UserProfiles";
  }

  async beforeDestroyLoadModel() {
    this.params.id = this.request.user.slug;
  }

  async login({ request, response }) {
    try {
      this.request = request;
      this.response = response;

      let customMessages = {
        required: "You forgot to give :attribute",
        email: "Invalid Email",
        "regex.password":
          "Password must contain atleast one number and one special character and should be 6 to 16 character long",
      };

      let rules = {
        email: "required|email",
        password: "required",
        device_type: "required|in:web,ios,android",
        device_token: "required",
      };
      let validator = await validateAll(request.body, rules, customMessages);
      let validation_error = this.validateRequestParams(validator);
      if (this.__is_error) return validation_error;

      let params = this.request.body;
      let user = await this.modal.getUserByEmail(params.email);

      // if (_.isEmpty(user))
      //     return this.sendError(
      //         'This email is not associated with any user',
      //         {},
      //         400
      //     );

      if (_.isEmpty(user) || !compareHash(params.password, user.password))
        return this.sendError("Incorrect email or password", {}, 400);

      if (user.login_type !== LOGIN_TYPE.CUSTOM) {
        return this.sendError(
          "Email already registered from different platform.",
          {},
          403
        );
      }

      if (!user.is_activated) {
        return this.sendError(
          "You have been de-activated by Admin. Kindly contact the administrator",
          {},
          403
        );
      }

      if (user.is_blocked) {
        return this.sendError(
          "You have been blocked by Admin. Kindly contact the administrator.",
          {},
          403
        );
      }

      if (
        (constants.SMS_VERIFICATION && !user.is_mobile_verify) ||
        (constants.EMAIL_VERIFICATION && !user.is_email_verify)
      ) {
        const payload = {};
        if (user.email) {
          payload.email = user.email;
        }
        if (user.mobile_no) {
          payload.mobile_no = user.mobile_no;
        }
        await UserOTP.instance().createRecord(this.request, payload);
        return this.sendError("Email is not verified.", {}, 428);
      }

      request.body.slug = user.slug;
      await UserApiToken.instance().createRecord(
        request,
        extractFields(request.body, UserApiToken.instance().getFields())
      );

      this.__is_paginate = false;
      await this.sendResponse(200, "User logged in successfully!", user);
      return;
    } catch (err) {
      return this.sendError(
        "Internal server error. Please try again later.",
        {},
        500
      );
    }
  }

  async socialLogin({ request, response }) {
    this.request = request;
    this.response = response;
    const params = request.body;
    let socialUser;

    let customMessages = {
      required: "You forgot to give :attribute",
      email: "Invalid Email",
      "regex.password":
        "Password must contain atleast one number and one special character and should be 6 to 16 character long",
    };

    let rules = {
      email: "email|max:50",
      platform_id: "required|max:255",
      platform_type: "required|in:facebook,google,apple",
      device_type: "required|in:web,android,ios",
      device_token: "required",
    };
    let validator = await validateAll(params, rules, customMessages);
    let validation_error = this.validateRequestParams(validator);
    if (this.__is_error) return validation_error;

    if (!_.isEmpty(params.email)) {
      await SocialUser.instance().findOrCreateRecord(
        this.request,
        extractFields(params, SocialUser.instance().getFields())
      );
    } else {
      const saved_user = await SocialUser.instance().getUserRecord(
        params.platform_id,
        params.platform_type
      );
      if (!_.isEmpty(saved_user)) {
        params.email = saved_user.email;
        request.body.email = saved_user.email;
        request.body.name = saved_user.name;
      }
    }
    if (!_.isEmpty(params.email)) {
      socialUser = await this.modal.getUserByEmail(params.email);
    }
    // if (_.isEmpty(socialUser)) {
    //     socialUser = await this.modal.getUserByPlatformID(params.platform_type, params.platform_id);
    // }

    if (_.isEmpty(socialUser) && !params.email) {
      return this.sendError("Not able to sign up without email", {}, 403);
    }

    if (!_.isEmpty(socialUser)) {
      if (socialUser.login_type !== params.platform_type) {
        return this.sendError(
          "Email already registered from different platform.",
          {},
          400
        );
      }

      if (!socialUser.is_activated) {
        return this.sendError(
          "You have been de-activated by Admin. Kindly contact the administrator",
          {},
          403
        );
      }
      console.log("Block Status", socialUser.is_blocked);

      if (socialUser.is_blocked) {
        return this.sendError(
          "You have been blocked by Admin. Kindly contact the administrator.",
          {},
          403
        );
      }
    }

    let user = await this.modal.socialLogin(request);

    this.__is_paginate = false;
    await this.sendResponse(200, "User logged in successfully", user);
    return;
  }

  async getSearchUser({ request, response }) {
    try {
      this.request = request;
      this.response = response;
      const user_slug = this.request.user.slug;
      const search_user = this.request.query.name || "";
      console.log(this.request.query);

      const record = await this.modal.getSearchUser(
        this.request,
        user_slug,
        search_user
      );

      this.resource = "SearchUser";
      return this.sendResponse(
        200,
        "Retreived searched user successfully",
        record
      );
    } catch (err) {
      console.log(err);
      return this.sendError(
        "Internal server error. Please try again later",
        {},
        500
      );
    }
  }

  async setNewPassword({ request, response }) {
    this.request = request;
    this.response = response;
    const user = this.request.user;
    const params = this.request.body;

    let rules = {
      new_password: [
        "required",
        "regex:/^(?=.*[0-9])(?=.*[!@#$%^&*])[a-zA-Z0-9!@#$%^&*]{6,16}$/",
      ],
      confirm_password: "required|same:new_password",
    };
    let validator = await validateAll(params, rules);
    let validation_error = this.validateRequestParams(validator);
    if (this.__is_error) return validation_error;

    //update new password
    let update_params = {
      password: generateHash(params.new_password),
    };
    //update user
    await this.modal.updateUser({ email: user.email }, update_params);
    await UserApiToken.instance().deleteRecord(user.slug);
    await UserOTP.instance().deleteRecord(user?.email, user?.mobile_no);

    this.__is_paginate = false;
    return this.sendResponse(200, "Password reset successfully", {});
  }

  async forgotPassword({ request, response }) {
    this.request = request;
    this.response = response;
    let params = request.body;

    let rules = {
      email: "required",
    };
    let validator = await validateAll(params, rules);
    let validation_error = this.validateRequestParams(validator);
    if (this.__is_error) return validation_error;

    //get user by email
    let user = await this.modal.getUserByEmail(params.email);
    if (_.isEmpty(user))
      return this.sendError(
        "This email is not associated with any user.",
        {},
        400
      );
    try {
      await UserOTP.instance().createRecord(
        this.request,
        extractFields(user, UserOTP.instance().getFields())
      );
      // const record = await this.modal.forgotPassword(user);
    } catch (err) {
      return this.sendError("Failed to send mail", {}, 500);
    }

    this.__collection = false;
    this.__is_paginate = false;
    this.sendResponse(200, "Otp has been sent to your email", {});
    return;
  }

  async changePassword({ request, response }) {
    this.request = request;
    this.response = response;
    //validation rules
    let rules = {
      current_password: "required",
      new_password: [
        "required",
        "regex:/^(?=.*[0-9])(?=.*[!@#$%^&*])[a-zA-Z0-9!@#$%^&*]{6,16}$/",
      ],
      confirm_password: "required|same:new_password",
    };
    let validator = await validateAll(request.body, rules);
    let validation_error = this.validateRequestParams(validator);
    if (this.__is_error) return validation_error;

    let user = this.request.user;
    let params = this.request.body;

    if (user.login_type !== LOGIN_TYPE.CUSTOM) {
      return this.sendError(
        "Not able to change password. Not a custom user",
        {},
        400
      );
    }

    //check old password
    let checkCurrentPass = await compareHash(
      params.current_password,
      user.password
    );
    if (!checkCurrentPass)
      return this.sendError("Invalid current password", {}, 400);
    //check current and old password
    if (params.current_password == params.new_password)
      return this.sendError(
        "Current password is same as new password",
        {},
        400
      );
    //update new password
    let update_params = {
      password: generateHash(params.new_password),
    };
    //update user
    await this.modal.updateUser({ email: user.email }, update_params);

    //remove all api token except current api token
    await UserApiToken.instance().deleteRecord(user.slug);

    this.__is_paginate = false;
    this.__collection = false;
    this.sendResponse(200, "Password updated successfully", {});
    return;
  }

  async logout({ request, response }) {
    this.request = request;
    this.response = response;

    const user_slug = request.user.slug;
    const record = await UserApiToken.instance().deleteRecord(user_slug);

    this.__is_paginate = false;
    this.__collection = false;

    return this.sendResponse(200, "User Logout Successfully", {});
  }

  async getMyProfile({ request, response }) {
    this.request = request;
    this.response = response;

    const record = await this.modal.getMyProfile(request);

    this.resource = "MyProfile";
    this.__is_paginate = false;
    return await this.sendResponse(
      200,
      "Profile retreived successfully",
      record
    );
  }

  async pushNotification({ request, response }) {
    try {
      this.request = request;
      this.response = response;
      this.__is_paginate = false;

      const { status } = request.body;

      let rules = {
        status: "required",
      };

      let validator = await validateAll(request.body, rules);
      let validation_error = this.validateRequestParams(validator);
      if (this.__is_error) return validation_error;

      const user_slug = request.user.slug;

      const record = await this.modal.updateNotificationStatus(
        user_slug,
        status
      );

      if (!record) {
        return await this.sendResponse(
          "Notification status updated failed",
          {},
          500
        );
      }

      return await this.sendResponse(
        200,
        "Notification status updated successfully",
        record
      );
    } catch (e) {
      console.log(e.message);
      return await this.sendResponse(
        "Notification status updated failed",
        {},
        500
      );
    }
  }

  async updateNotificationToken({ request, response }) {
    try {
      this.request = request;
      this.response = response;

      const { token } = request.body;

      let rules = {
        token: "required",
      };

      let validator = await validateAll(request.body, rules);
      let validation_error = this.validateRequestParams(validator);
      if (this.__is_error) return validation_error;
      
      const user_slug = request.user.slug;

      const record = await this.modal.updateFcmToken(user_slug, token);

      this.__is_paginate = false;

      if (!record) {
        return await this.sendResponse("Fcm token updated failed", {}, 500);
      }

      return await this.sendResponse(
        200,
        "Fcm token updated successfully",
        record
      );
    } catch (e) {
      console.log(e.message);
      return await this.sendResponse("Fcm token updated failed", {}, 500);
    }
  }

  async getPushNotificationStatus({ request, response }) {
    try {
      this.request = request;
      this.response = response;

      const user_slug = request.user.slug;

      const record = await this.modal.getPushNotificationStatus(user_slug);
      this.__is_paginate = false;

      return response.status(200).json({
        code: 200,
        message: "Notification status found",
        status: record ? 1 : 0,
      });
    } catch (e) {
      console.log(e.message);
      return response.status(500).json({
        code: 500,
        message: "Notification status not found",
      });
    }
  }
}

module.exports = UserController;
